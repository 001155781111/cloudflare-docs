---
title: Access Durable Objects Storage
pcx_content_type: concept
sidebar:
  order: 4

---

import { Render } from "~/components";

Durable Objects are a powerful compute API that provides a compute with storage building block. Each Durable Object has its own private, transactional and strongly consistent storage. By default, key-value storage is available. SQL storage(/durable-objects/best-practices/access-durable-objects-storage/#sql-storage) is available on a new beta version of Durable Objects.

A Durable Object's [in-memory state](/durable-objects/reference/in-memory-state/) is preserved as long as the Durable Object is not evicted from memory. Inactive Durable Objects with no incoming request traffic can be evicted. There are normal operations like [code deployments](/workers/configuration/versions-and-deployments/) that trigger Durable Objects to restart and lose their in-memory state. For these reasons, you should use Durable Objects Storage API to persist state durably on disk that needs to survive eviction or restart of Durable Objects. 

## Access storage

[Storage API](/durable-objects/api/storage-api/#methods) methods are available on `ctx.storage` parameter passed to the Durable Object constructor.

A common pattern is to initialize a Durable Object from [persistent storage](/durable-objects/api/storage-api/) and set instance variables the first time it is accessed. Since future accesses are routed to the same Durable Object, it is then possible to return any initialized values without making further calls to persistent storage.


```ts
export class Counter extends DurableObject {
  value: number;

  constructor(ctx: DurableObjectState, env: Env) {
    super(ctx, env);

    // `blockConcurrencyWhile()` ensures no requests are delivered until
    // initialization completes.
    ctx.blockConcurrencyWhile(async () => {
      // After initialization, future reads do not need to access storage.
      this.value = (await ctx.storage.get("value")) || 0;
    });
  }

  async getCounterValue() {
    return this.value;
  }
}
```

## SQL Storage

:::note[SQLite in Durable Objects Beta]

New beta version of Durable Objects is available where each Durable Object has a private, embedded SQLite database. When deploying a new Durable Object class, users can opt-in to using SQL storage in order to access [Storage SQL API methods](/durable-objects/api/storage-api/#sqlexec). Otherwise, a Durable Object class has the standard, private key-value storage.

:::

To allow a new Durable Object class to use SQL storage and API, use `new_sqlite_classes` on the migration in your Worker's `wrangler.toml` file:

```toml
[[migrations]]
tag = "v1" # Should be unique for each entry
new_sqlite_classes = ["MyDurableObject"] # Array of new classes
```

[SQL API methods](/durable-objects/api/storage-api/#sqlexec) are available on `ctx.storage.sql` parameter passed to the Durable Object constructor.

### Examples

<Render file="durable-objects-sql" />

<Render file="durable-objects-vs-d1" />

## Related resources

* [Zero-latency SQLite storage in every Durable Object blog post](https://blog.cloudflare.com/sqlite-in-durable-objects)
